// Copyright (c) 2019, 2022 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: paketo-buildpacks-intro
:page-layout: guide-multipane
:page-duration: 20 minutes
:page-releasedate: 2019-07-23
:page-description: Learn how to build your microservices and run them with Open Liberty using containers.
:page-tags: ['Docker']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes-intro']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:source-highlighter: prettify
:page-seo-title: Building and containerizing microservices with Paketo Buildpacks 
:page-seo-description: A getting started tutorial with examples of how to build Open Container Initiative (OCI) images with Paketo Buildpacks and deploying them in popular container managers like Docker and Podman.  
:guide-author: Open Liberty
= Containerizing microservices with Paketo Buildpacks and Docker

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the  https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to build your microservices with Paketo and Open Liberty while using Docker to containerize them.

// =================================================================================================
//  What you'll learn
// =================================================================================================

== What you'll learn

You can easily deploy your microservices in different environments in a lightweight and portable manner by using containers. From development to production and across your DevOps environments, you can deploy your microservices consistently and efficiently with containers. You can run a container from a container image. Each container image is a package of what you need to run your microservice or application, from the code to its dependencies and configuration.

You'll learn how to build your microservices into OCI images with `Paketo` buildpacks and run them with your preferred container manager, such as `Podman` or `Docker`. You'll specify the buildpacks and builder to be utilized in the `pack build` command and run your images in containers.

The microservice that you'll be working with is called `system`. The `system` miroservice return the JVM system properties of the running container. The guide demonstraes how microservices can be built with `Paketo Buildpacks` and run them with your preferred container manager.

== Additional prerequisites

Before starting the guide, ensure that you have installed the `Pack CLI` and a container manager such as `Podman` or `Docker`. For installationof the `Pack CLI`, refer to the https://buildpacks.io/docs/tools/pack/[offical Pack documentation^] and for installation of a container manager, refer to https://podman.io/getting-started/installation[Offical Podman Documentation^] or the https://docs.docker.com/get-docker/[official Docker documentation^].

///////////////////////////
// Getting started
///////////////////////////

[role='command']
include::{common-includes}/gitclone.adoc[]

== Packaging your microservices

// static guide instructions:
Navigate to the `start` directory to begin.

You can find the starting Java project in the `start` directory. This project contains a single microservice called `system`, which can be found in the corresponding directory, `system`.

To try out the microservice by using Maven, run the following Maven goal to build the `system` microservice and run it inside Open Liberty:
[role='command']
```
mvn -pl system liberty:run
```

After you see the following message in the command-line session, your service is ready:

[source, role="no_copy"]
----
The defaultServer server is ready to run a smarter planet.
----

To access the `system` service, which shows the system properties of the running JVM, see http://localhost:9080/system/properties[^].

// static guide instructions:
After you are finished checking out the microservice, stop the Open Liberty server by pressing `CTRL+C` in the command-line session where you ran the server. Alternatively, you can run the `liberty:stop` goal in another command-line session:
[role='command']
```
mvn -pl system liberty:stop
```

To package your microservice, run the maven package goal to build the application `.war` files from the start directory so that the `.war` file is in the `system/target` directory.

[role='command']
```
mvn package
```

To learn more about RESTful web services and how to build them, see https://openliberty.io/guides/rest-intro.html[Creating a RESTful web service^] for details about how to build the `system` service. 

== Building images with Paketo buildpacks

Before attempting to build your image, ensure that you have installed https://buildpacks.io/docs/tools/pack/[Pack CLI]. The `Pack CLI` tool facilitates the use of buildpacks and provides functionality to build and rebase back images with buildpacks.

`Paketo buildpacks` is an open source project which provides users with production-ready buildpacks for the most popular languages and framworks, including the Open Liberty runtime. A `buildpack` is a set of executables that inspects and transforms your application source code into Open Container Initiative (OCI) images that can be ran in nearly any container manager.

When a `buildpack` is executed, there are two phases that occur, the `detect` phase and the `build` phase. The `detect` phase checks against your application source code to ensure the buildpack is applicable. If applicable, the `build` phase will run which downloads all of the application dependencies, compile your source code and constructs a container image for your application.

The benefits of using `Paketo buildpacks` to build your application compared to other build tools such as `podman build` and `docker build`, include:

* Generating your application images without a Containerfile or Dockerfile.
* Advanced image cacheing for faster rebuild times of your application.
* Generate a software bill-of-materials (SBOM) which provides information on the contents of your final image.
* Optimizing image size for minimal final application image.
* Auto-detection and installation of your app's dependencies directly from it's source code.
* Patching OS-level vulnerabilites in your images automatically upon rebuilding.

To start building your OCI image, set your `pack` default builder to the `Paketo buildpacks` builder with the following command:
[role='command']
```
pack config default-builder gcr.io/paketo-buildpacks/builder:base
```

A `builder` in the buildpack ecosystem, is an image comprised of three parts:

* A set of buildpacks that apply your application's dependencies.
* A stack, which provides the OS layer for your appliation image.
* A lifecycle which analyzes, detects and assembles your final application image.

To construct your `system` service image, begin with the following `pack build` command and the applicable flags and variables to customize your Open Liberty image:
include::{common-includes}/os-tabs.adoc[]

[.subsection_link.tab_link.podman_link]
`*PODMAN*`
[.subsection_link.tab_link.docker_link]
`*DOCKER*`

[.tab_content.windows_section]
--
Begin with running the following command to build the `system` service:
[role='command']


[.subsection_content.tab_content.docker_link]
--
```
pack build --path ./system ^
--env BP_JAVA_APP_SERVER=liberty ^
--env BP_MAVEN_BUILT_ARTIFACT="target/*.[ejw]ar src/main/liberty/config/*" ^
--env BP_LIBERTY_PROFILE=jakartaee9 ^
--buildpack paketo-buildpacks/eclipse-openj9 ^
--buildpack paketo-buildpacks/java system:1.0-SNAPSHOT
```
--
--
[.tab_content.mac_section.linux_section]
--
Run the following command to build the `system` service:
[role='command']
```
pack build --path ./system \
--env BP_JAVA_APP_SERVER=liberty \
--env BP_MAVEN_BUILT_ARTIFACT="target/*.[ejw]ar src/main/liberty/config/*" \
--env BP_LIBERTY_PROFILE=jakartaee9 \
--buildpack paketo-buildpacks/eclipse-openj9 \
--buildpack paketo-buildpacks/java system:1.0-SNAPSHOT
```

pack build --path ./system \
--env BP_JAVA_APP_SERVER=liberty \
--env BP_MAVEN_BUILT_ARTIFACT="target/*.[ejw]ar src/main/liberty/config/*" \
--env BP_LIBERTY_PROFILE=jakartaee9 \
--buildpack paketo-buildpacks/eclipse-openj9 \
--buildpack paketo-buildpacks/java \
--docker-host=inherit \
--trust-builder=true system:1.0-SNAPSHOT

--

The following table describes the flags and environment variables supplied to customize your Open Liberty image:
[cols="35, 100", options="header"]
|===
| *Flag*                  | *Description*
| --path                  | Relative path to your application source code.
| --buildpack             | Buildpack to be included in the OCI build process.
| --env                   | Enviornment variables for the `pack build` process.
|===

The following table describes the environment variables supplied for your application image. 
[cols="35, 100", options="header"] 
|===
| *Enviornment Variables* | *Description*
| BP_JAVA_APP_SERVER      | The application server to use, in the case it's `Liberty`.
| BP_MAVEN_BUILT_ARTIFACT | Include the `server.xml` information from Maven into the `pack build` process.
| BP_LIBERTY_PROFILE      | The Liberty profile to use. Defaults to `full`.
|===


Explore all of the flags, variables and options available for the Paketo Liberty buildpack on the https://github.com/paketo-buildpacks/liberty[Paketo Liberty page^]. 

== Running your microservices in containers

Now that your `system` image is built, you will now run your microservice in a container. Since the final images that are generated from the `Pack CLI` are Open Container Initiative (OCI) images, they are compatible with nearly all of the most popular container managers such as `Podman` and `Docker`. 

[.tab_link.podman_link]
`*PODMAN*`
[.tab_link.docker_link]
`*DOCKER*`

[.tab_content.podman_section]
--
[role='command']
```
podman run --rm -d --name system -p 9080:9080 system:1.0-SNAPSHOT 
```
--

[.tab_content.docker_section]
--
[role='command']
```
docker run --rm -d --name system -p 9080:9080 system:1.0-SNAPSHOT 
```
--

The following table describes the flags in these commands:

[cols="15, 100", options="header"]
|===
| *Flag* | *Description*
| --rm   | Removes the container when the container is stopped.
| -d     | Runs the container in the background.
| --name | Specifies a name for the container.
| -p     | Maps the host ports to the container ports. For example: `-p <HOST_PORT>:<CONTAINER_PORT>`
|===

Next, run the `docker ps` command to verify that your container are started:

[role='command']
```
docker ps
```

Make sure that your containers are running and show `Up` as their status:

[role="no_copy"]
----
CONTAINER ID    IMAGE                   COMMAND                  CREATED          STATUS          PORTS                                        NAMES
99a98313705f    system:1.0-SNAPSHOT     "/opt/ol/helpers/runâ€¦"   3 seconds ago    Up 2 seconds    0.0.0.0:9080->9080/tcp, 9443/tcp             system
----

If a problem occurs and your containers exit prematurely, the containers don't appear in the container list that the `docker ps` command displays. Instead, your container appear with an `Exited` status when they run the `docker ps -a` command. Run the `docker logs system` command to view the container logs for any potential problems. Run the `docker stats system` commands to display a live stream of usage statistics for your container. When you find the cause of the issues, remove the faulty container with the `docker rm system` command. Rebuild your image, and start the container again.

// static guide instructions:
To acces the `system` service, which shows the system properties of the running JVM, see `http://localhost:9080/system/properties`

== Externalizing server configuration

// File 0
inventory/server.xml
[source, xml, linenums, indent=0, role="code_column"]
----
include::finish/inventory/src/main/liberty/config/server.xml[]
----

As mentioned at the beginning of this guide, one of the advantages of using containers is that they are portable and can be moved and deployed efficiently across all of your DevOps environments. Configuration often changes across different environments, and by externalizing your server configuration, you can simplify the development process.

Imagine a scenario where you are developing an Open Liberty application on port `9081` but to deploy it to production, it must be available on port `9091`. To manage this scenario, you can keep two different versions of the `server.xml` file; one for production and one for development. However, trying to maintain two different versions of a file might lead to mistakes. A better solution would be to externalize the configuration of the port number and use the value of an environment variable that is stored in each environment. 

In this example, you will use an environment variable to externally configure the HTTP port number of the `inventory` service. 

In the [hotspot file=0]`inventory/server.xml` file, the [hotspot=httpPort file=0]`default.http.port` variable is declared and is used in the [hotspot=httpEndpoint file=0]`httpEndpoint` element to define the service endpoint. The default value of the [hotspot=httpPort file=0]`default.http.port` variable is `9081`. However, this value is only used if no other value is specified. You can replace this value in the container by using the -e flag for the podman run command. 

Run the following commands to stop and remove the `inventory` container and rerun it with the `default.http.port` environment variable set:

[role='command']
```
docker stop inventory
docker rm inventory 
docker run -d --name inventory -e default.http.port=9091 -p 9091:9091 inventory:1.0-SNAPSHOT
```

The `-e` flag can be used to create and set the values of environment variables in a Docker container. In this case, you are setting the `default.http.port` environment variable to `9091` for the `inventory` container.

Now, when the service is starting up, Open Liberty finds the `default.http.port` environment variable and uses it to set the value of the [hotspot=httpPort file=0]`default.http.port` variable to be used in the HTTP endpoint.

// static guide instructions:
The `inventory` service is now available on the new port number that you specified. You can see the contents of the inventory at the http://localhost:9091/inventory/systems[http://localhost:9091/inventory/systems^] URL. You can add your local system properties at `\http://localhost:9091/inventory/systems/pass:c[[system-ip-address]]` by replacing `[system-ip-address]` with the IP address that you obtained in the previous section. The `system` service remains unchanged and is available at the http://localhost:9080/system/properties[http://localhost:9080/system/properties^] URL.

You can externalize the configuration of more than just the port numbers. To learn more about Open Liberty server configuration, check out the https://openliberty.io/docs/latest/reference/config/server-configuration-overview.html[Server Configuration Overview^] docs. 

== Testing the microservices

You can test your microservices manually by hitting the endpoints or with automated tests that check your running Docker containers.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `SystemEndpointIT` class.#
`system/src/test/java/it/io/openliberty/guides/system/SystemEndpointIT.java`
----

SystemEndpointIT.java
[source, java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/system/src/test/java/it/io/openliberty/guides/system/SystemEndpointIT.java[]
----

The [hotspot=testGetProperties file=0]`testGetProperties()` method checks for a `200` response code from the `system` service endpoint.

=== Running the tests
// static guide instructions
Run the Maven `package` goal to compile the test classes. Run the Maven `failsafe` goal to test the services that are running in the Docker containers by replacing the `[system-ip-address]` with the IP address that you determined previously.

[role='command']
```
mvn package
mvn failsafe:integration-test -Dsystem.ip=[system-ip-address]  -Dsystem.http.port=9080
```

If the tests pass, you see output similar to the following example:

[role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.system.SystemEndpointIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.653 s - in it.io.openliberty.guides.system.SystemEndpointIT

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

----

When you are finished with the service, run the following command to stop and remove your container:

[role='command']
```
docker stop system
```


== Great work! You're done!


You have just built Docker images and run two microservices on Open Liberty in containers. 

include::{common-includes}/attribution.adoc[]
